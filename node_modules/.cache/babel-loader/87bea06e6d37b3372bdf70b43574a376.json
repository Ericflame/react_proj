{"ast":null,"code":"// 可以发送异步ajax请求的函数模块 封装ajax库\n// 函数的返回值是一个promise对象\n\n/* \r\n  1、优化1：统一处理请求异常\r\n      在外层包一个自己创建的promise对象\r\n      在请求出错时 不执行reject(error) 而是显示错误提示\r\n  \r\n  2、优化2：异步得到不是reponse 而是response.data\r\n      在请求成功resolve时：resolve(response.data)\r\n*/\nimport axios from 'axios';\nimport qs from 'querystring';\nconst instance = axios.create({\n  timeout: 4000\n}); //请求拦截器\n// Add a request interceptor\n\ninstance.interceptors.request.use(config => {\n  const {\n    method,\n    data\n  } = config;\n\n  if (method.toLowerCase() === 'post') {\n    if (data instanceof Object) {\n      config.data = qs.stringify(data);\n    }\n  }\n\n  return config;\n}); //响应拦截器\n// Add a response interceptor\n\ninstance.interceptors.response.use(response => {\n  //请求若成功\n  return response;\n}, //请求若失败\nerror => {\n  return Promise.reject();\n});\nexport default instance;","map":{"version":3,"sources":["C:/Users/PC/Desktop/react-project/src/api/myAxios.js"],"names":["axios","qs","instance","create","timeout","interceptors","request","use","config","method","data","toLowerCase","Object","stringify","response","error","Promise","reject"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,EAAP,MAAe,aAAf;AAEA,MAAMC,QAAQ,GAAGF,KAAK,CAACG,MAAN,CAAa;AAC5BC,EAAAA,OAAO,EAAC;AADoB,CAAb,CAAjB,C,CAKA;AACA;;AACAF,QAAQ,CAACG,YAAT,CAAsBC,OAAtB,CAA8BC,GAA9B,CAAmCC,MAAD,IAAY;AAE5C,QAAM;AAACC,IAAAA,MAAD;AAAQC,IAAAA;AAAR,MAAgBF,MAAtB;;AACA,MAAGC,MAAM,CAACE,WAAP,OAAyB,MAA5B,EAAmC;AACjC,QAAGD,IAAI,YAAYE,MAAnB,EAA0B;AACxBJ,MAAAA,MAAM,CAACE,IAAP,GAAcT,EAAE,CAACY,SAAH,CAAaH,IAAb,CAAd;AACD;AACF;;AACD,SAAOF,MAAP;AAED,CAVD,E,CAYA;AACA;;AACAN,QAAQ,CAACG,YAAT,CAAsBS,QAAtB,CAA+BP,GAA/B,CACGO,QAAD,IAAc;AAEZ;AACF,SAAOA,QAAP;AACD,CALD,EAOI;AACDC,KAAD,IAAS;AACT,SAAOC,OAAO,CAACC,MAAR,EAAP;AACD,CAVD;AAYA,eAAef,QAAf","sourcesContent":["// 可以发送异步ajax请求的函数模块 封装ajax库\r\n// 函数的返回值是一个promise对象\r\n\r\n/* \r\n  1、优化1：统一处理请求异常\r\n      在外层包一个自己创建的promise对象\r\n      在请求出错时 不执行reject(error) 而是显示错误提示\r\n  \r\n  2、优化2：异步得到不是reponse 而是response.data\r\n      在请求成功resolve时：resolve(response.data)\r\n*/\r\n\r\nimport axios from 'axios'\r\nimport qs from 'querystring'\r\n\r\nconst instance = axios.create({\r\n  timeout:4000\r\n})\r\n\r\n\r\n//请求拦截器\r\n// Add a request interceptor\r\ninstance.interceptors.request.use((config) => {\r\n\r\n  const {method,data} = config\r\n  if(method.toLowerCase() === 'post'){\r\n    if(data instanceof Object){\r\n      config.data = qs.stringify(data)\r\n    }\r\n  }\r\n  return config\r\n  \r\n});\r\n\r\n//响应拦截器\r\n// Add a response interceptor\r\ninstance.interceptors.response.use(\r\n  (response) => {\r\n\r\n    //请求若成功\r\n  return response;\r\n}, \r\n\r\n    //请求若失败\r\n  (error)=>{\r\n  return Promise.reject();\r\n});\r\n\r\nexport default instance\r\n\r\n"]},"metadata":{},"sourceType":"module"}